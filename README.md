# safe_rm

Safer version of rm(1), works by moving files to an intermediate directory before unlinking them from the filesystem. They stay in that directory for a specified amount of time

Differs from rm in its options most notably does not have -f option or similar which forces files to be removed without any prompts to the user. There are no promts to the user about any file deletion because safe\_rm hopes to solve any such problems. Also, because a time can be specified for files, safe\_rm cannot take multiple files as rm does. Although this may be looked into in the future. 

# Why Go?

This project was originally written in Rust although I had trouble with the language and instead decided to write it in Go. This isn't a particularly ambitious project regardless of language, it exists because I needed it and because I wanted to use another language than C or C++. My experience with Go was a very positive one, as I expect it will be for anyone who uses C often, the languages are very similar. It is still unclear what Go is useful for however. I found that returning multiple values is more convenient than how say Boost does errors in C++. I'm used to dealing with errno in C for system calls or other low level routines and it didn't seem like Go's solution was any better than this if at all. I felt more inclined to deal with errors in Go, of course, but it made the code extremely verbose. It seems to me that Rust's error handling is much more ergonomic and modern. In theory I like Rust more, but it was very difficult to get into while Go was extremely easy as a C programmer. I was in constant battle with the Rust compiler, however I did really enjoy the language. It was just such a large battle I couldn't end up producing code that I was at all happy with, it's idioms have a much higher learning curve than Go does, but I understand why, and I am truly excited for the future of Rust. Go was a joy to write in and I could see myself using it in the future, I love a small language and Go feels like C with extra goodies, no language however will ever replace what C is to me, I will continue using C for any projects of substance. 
